#include "common.h"

// file functions
#define MY_REG_FILE     "save\\registry.txt"
#define MY_REG_FILE_WAL "save\\registry.wal"
#define MY_REG_FILE_SUM "save\\registry.sum"
#define MAX_REG_ITEM 100

struct reg_item {
    char *key1;
    char *key2;
    unsigned val;
};

static struct reg_item reg[MAX_REG_ITEM];
static int nr_reg;
static int reg_dirty = 0;

enum reg_merge_op {
    REG_MERGE_DISABLE,
    REG_MERGE_OR,
    REG_MERGE_OR1,
    REG_MERGE_UMAX,
    REG_MERGE_IMAX,
};
struct reg_known_item {
    char *key1;
    char *key2;
    unsigned default_val;
    enum reg_merge_op merge_op;
};

static struct reg_known_item reg_known[] = {
    { "SOFTWARE\\SOFTSTAR\\PAL3A_MOVIE"   , "MOVIE_A" , 0  , REG_MERGE_OR      },

    { "SOFTWARE\\SOFTSTAR\\PAL3A_SAVE"    , "FINISH"  , 0  , REG_MERGE_OR1     },
    { "SOFTWARE\\SOFTSTAR\\PAL3A_SAVE"    , "SEEK"    , 0  , REG_MERGE_DISABLE },
    { "SOFTWARE\\SOFTSTAR\\PAL3A_SAVE"    , "snap"    , 0  , REG_MERGE_IMAX    },

    { "SOFTWARE\\SOFTSTAR\\PAL3A_SUBGAME" , "LEVEL"   , -1 , REG_MERGE_IMAX    },

    { "SOFTWARE\\SOFTSTAR\\PAL3A_TASK"    , "SEEK"    , 0  , REG_MERGE_DISABLE },

    { NULL, NULL } // EOF
};

static unsigned reg_merge(unsigned val1, unsigned val2, unsigned op)
{
    switch (op) {
        case REG_MERGE_OR: return val1 | val2;
        case REG_MERGE_OR1: return val1 || val2;
        case REG_MERGE_UMAX: return val1 > val2 ? val1 : val2;
        case REG_MERGE_IMAX: return (int)val1 > (int)val2 ? val1 : val2;
    }
    return val1;
}

static int reg_cmp(const void *a, const void *b)
{
    const struct reg_item *pa = a, *pb = b;
    int ret = strcmp(pa->key1, pb->key1);
    if (ret) return ret;
    return strcmp(pa->key2, pb->key2);
}
static int alloc_reg()
{
    if (nr_reg >= MAX_REG_ITEM) fail("too many registry items.");
    return nr_reg++;
}
static void load_reg()
{
    nr_reg = 0;
    FILE *fp;
    char buf[MAXLINE];
    char *ptr;
    char key1[MAXLINE], key2[MAXLINE];
    unsigned val;
    int ret;
    int badreg_flag = 0;

    if (!wal_check1(MY_REG_FILE, MY_REG_FILE_WAL, MY_REG_FILE_SUM)) badreg_flag = 1;

    fp = robust_fopen(MY_REG_FILE, "r");
    if (!fp) return;

    fscanf(fp, UTF8_BOM_STR);
    while (fgets(buf, sizeof(buf), fp)) {
        // ltrim the line
        for (ptr = buf; *ptr && is_spacechar(*ptr); ptr++);
        memmove(buf, ptr, strlen(ptr) + 1);
        
        // skip empty and comment lines
        if (!buf[0] || buf[0] == ';' || buf[0] == '#' || (buf[0] == '/' && buf[1] == '/')) continue;
        
        // remove '\n' and end of line
        ptr = strchr(buf, '\n');
        if (ptr) *ptr = '\0';
        
        // read registry tuple
        ret = sscanf(buf, MAXLINEFMT MAXLINEFMT "%x ", key1, key2, &val);
        if (ret == 3) {
            int id = alloc_reg();
            reg[id].key1 = strdup(key1);
            reg[id].key2 = strdup(key2);
            reg[id].val = val;
        } else {
            badreg_flag = 1;
        }
    }
    fclose(fp);
    
    if (badreg_flag == 1) {
        if (MessageBoxW(NULL, wstr_badregfile_text, wstr_badregfile_title, MB_ICONWARNING | MB_TOPMOST | MB_SETFOREGROUND | MB_YESNO | MB_DEFBUTTON2) == IDNO) {
            fail("registry save file has error, user abort.");
        }
    }
    
    qsort(reg, nr_reg, sizeof(struct reg_item), reg_cmp);
    int i;
    for (i = 1; i < nr_reg; i++) {
        if (reg_cmp(&reg[i - 1], &reg[i]) == 0) {
            fail("duplicate registry key:\n  '%s'\n  '%s'", reg[i].key1, reg[i].key2);
        }
    }
}
static void save_reg()
{
    PrepareDir(); // call PrepareDir() to create the "./save" Directory
    qsort(reg, nr_reg, sizeof(struct reg_item), reg_cmp);
    static int ask_retry = 1;
    FILE *fp;
    int i;

    if (!reg_dirty) return;

retry:
    fp = robust_fopen(MY_REG_FILE_WAL, "w");
    if (!fp) goto fail;

    fputs(UTF8_BOM_STR, fp);
    fprintf(fp, "; PAL3A registry save file\n");
    fprintf(fp, "; generated by PAL3Apatch %s (built on %s)\n", patch_version, build_date);
    SYSTEMTIME SystemTime;
    GetLocalTime(&SystemTime);
    fprintf(fp, "; last modification: %04hu-%02hu-%02hu %02hu:%02hu:%02hu.%03hu\n", SystemTime.wYear, SystemTime.wMonth, SystemTime.wDay, SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond, SystemTime.wMilliseconds);
    fprintf(fp, "\n");
    fprintf(fp, "%-40s%-15s%s\n", "; HKLM subkey", "name", "value");
    fprintf(fp, "\n");
    for (i = 0; i < nr_reg; i++) {
        fprintf(fp, "%-40s%-15s%08X\n", reg[i].key1, reg[i].key2, reg[i].val);
    }
    fclose(fp);

    if (!wal_replace1(MY_REG_FILE, MY_REG_FILE_WAL, MY_REG_FILE_SUM)) goto fail;
    
    reg_dirty = 0;
    return;

fail:
    if (ask_retry) {
        try_goto_desktop();
        if (MessageBoxW(game_hwnd, wstr_cantsavereg_text, wstr_cantsavereg_title, MB_ICONWARNING | MB_TOPMOST | MB_SETFOREGROUND | MB_RETRYCANCEL) == IDRETRY) {
            goto retry;
        } else {
            ask_retry = 0;
        }
    }
}
static void assign_reg(const char *key1, const char *key2, unsigned val)
{
    int i;
    for (i = 0; i < nr_reg; i++) {
        if (strcmp(reg[i].key1, key1) == 0 && strcmp(reg[i].key2, key2) == 0) {
            if (reg[i].val != val) {
                reg[i].val = val;
                reg_dirty = 1;
            }
            goto done;
        }
    }
    int id = alloc_reg();
    reg[id].key1 = strdup(key1);
    reg[id].key2 = strdup(key2);
    reg[id].val = val;
    reg_dirty = 1;
done:
    save_reg();
}
static int query_reg(const char *key1, const char *key2, unsigned *pval)
{
    int i;
    for (i = 0; i < nr_reg; i++) {
        if (strcmp(reg[i].key1, key1) == 0 && strcmp(reg[i].key2, key2) == 0) {
            *pval = reg[i].val;
            return 1;
        }
    }
    return 0;
}

// no clean up functions, just let these strings leak





// registry functions
static void write_winreg(LPCSTR lpSubKey, LPCSTR lpValueName, DWORD Data)
{
    HKEY hKey;
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, lpSubKey, 0, "", REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, NULL) == ERROR_SUCCESS) {
        RegSetValueEx(hKey, lpValueName, 0, REG_DWORD, (CONST BYTE *) &Data, sizeof(DWORD));
        RegCloseKey(hKey);
    }
}
static int read_winreg(LPCSTR lpSubKey, LPCSTR lpValueName, LPDWORD lpData)
{
    HKEY hKey;
    DWORD dwType = REG_DWORD;
    DWORD dwSize = sizeof(DWORD);
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpSubKey, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS) {
        if (RegQueryValueEx(hKey, lpValueName, NULL, &dwType, (LPBYTE) lpData, &dwSize) == ERROR_SUCCESS) {
            RegCloseKey(hKey);
            return 1;
        }
        RegCloseKey(hKey);
    }
    *lpData = 0;
    return 0;
}

/*
    0: patch disabled (read and write windows registry only)
    1: merge data read from file and registry, write both
    2: read and write file only
*/
#define REGREDIRECT_MERGE 1
#define REGREDIRECT_FILEONLY 2
static int regredirect_flag;


// patch functions
static bool save_dword(LPCSTR lpSubKey, LPCSTR lpValueName, DWORD Data) // WriteReg
{
    // special dirty hack
    if (strcmp(lpSubKey, "SOFTWARE\\SOFTSTAR\\PAL3_S_GAME") == 0) return true;

    // write file
    assign_reg(lpSubKey, lpValueName, Data);
    if (regredirect_flag == REGREDIRECT_MERGE) {
        // always write windows registry if sync is enabled
        write_winreg(lpSubKey, lpValueName, Data);
    }
    return true;
}

static bool query_dword(LPCSTR lpSubKey, LPCSTR lpValueName, LPDWORD lpData) // CheckReg
{
    // read file
    int ret = query_reg(lpSubKey, lpValueName, (unsigned *) lpData);
    if (regredirect_flag == REGREDIRECT_MERGE) {
        if (ret) {
            // if we read data from file
            // sync data to windows registry
            write_winreg(lpSubKey, lpValueName, *lpData);
        } else {
            // if there is no data in file
            // try read registry and sync data to file
            read_winreg(lpSubKey, lpValueName, lpData);
            assign_reg(lpSubKey, lpValueName, *lpData);
        }
    } else {
        if (!ret) *lpData = 0;
    }

    // special dirty hack
    if (strcmp(lpSubKey, "SOFTWARE\\SOFTSTAR\\PAL3A_SUBGAME") == 0 && strcmp(lpValueName, "LEVEL") == 0) {
        if (*lpData == 4) *lpData = -1;
    }

    return true;
}


static void load_known()
{
    struct reg_known_item *item;
    for (item = reg_known; item->key1 && item->key2; item++) {
        if (regredirect_flag == REGREDIRECT_MERGE && item->merge_op != REG_MERGE_DISABLE) {
            unsigned val1;
            DWORD val2;
            if (!query_reg(item->key1, item->key2, &val1)) val1 = item->default_val;
            if (!read_winreg(item->key1, item->key2, &val2)) val2 = item->default_val;
            save_dword(item->key1, item->key2, reg_merge(val1, val2, item->merge_op));
        } else {
            DWORD tmp;
            query_dword(item->key1, item->key2, &tmp);
        }
    }
}


MAKE_PATCHSET(regredirect)
{
    regredirect_flag = flag;
    if (regredirect_flag != REGREDIRECT_MERGE && regredirect_flag != REGREDIRECT_FILEONLY) {
        fail("unknown regredirect_flag %d.", regredirect_flag);
    }
    
    load_reg();
    
    load_known();
    
    const unsigned char save_dword_func_magic[] = "\x55\x8B\xEC\x51\x53\x8B\x5D\x08\x56\x57\x33\xFF\x3B\xDF\x0F\x84";
    const unsigned save_dword_funcs[] = {
        0x00407E10, 0x0041DDD2, 0x00440039, 0x004546D5,
        0x0045A50A, 0x0045C9ED, 0x004A1460, 0x004A6012,
        0x00517C80,
    };
    
    unsigned i;
    for (i = 0; i < sizeof(save_dword_funcs) / sizeof(unsigned); i++) {
        check_code(save_dword_funcs[i], save_dword_func_magic, sizeof(save_dword_func_magic) - 1);
        make_jmp(save_dword_funcs[i], save_dword);
    }
    
    const unsigned char query_dword_func_magic[] = "\x55\x8B\xEC\x51\x8D\x45\x08\x50\x6A\x01\x6A\x00\xFF\x75\x08\x68";
    const unsigned query_dword_funcs[] = {
        0x00406C27, 0x0044017A, 0x0045CAA2, 0x0045DF84,
        0x004A1515, 0x00515FD0,
    };
    for (i = 0; i < sizeof(query_dword_funcs) / sizeof(unsigned); i++) {
        check_code(query_dword_funcs[i], query_dword_func_magic, sizeof(query_dword_func_magic) - 1);
        make_jmp(query_dword_funcs[i], query_dword);
    }
    
    add_atexit_hook(save_reg);
}
