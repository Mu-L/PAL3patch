#include "common.h"

#define PLUGIN_LOG_FILE "PAL3patch.plugin_log.txt"


static void make_plugin_log_header()
{
    static int flag = 0;
    if (flag) return;
    flag = 1;
    
    FILE *fp = fopen(PLUGIN_LOG_FILE, "w");
    if (fp) {
        fputs("\xEF\xBB\xBF", fp);
        fprintf(fp, "; PAL3patch Plugin Host Log File\n");
        fprintf(fp, "; generated by PAL3patch %s (built on %s)\n", patch_version, build_date);
    	fprintf(fp, "\n");
    	fprintf(fp, "%-23s | %-15s | %s\n", "; timestamp", "module", "message");
    	fprintf(fp, "\n");
        fclose(fp);
    }
}

static void write_plugin_log(const char *module, const char *message)
{
    make_plugin_log_header();
    
    FILE *fp = fopen(PLUGIN_LOG_FILE, "a");
    if (fp) {
        SYSTEMTIME SystemTime;
        GetLocalTime(&SystemTime);

        const char *curline = message;
        while (1) {
            fprintf(fp, "%04hu-%02hu-%02hu %02hu:%02hu:%02hu.%03hu | %-15s | ", SystemTime.wYear, SystemTime.wMonth, SystemTime.wDay, SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond, SystemTime.wMilliseconds, module);
            const char *nextline = strchr(curline, '\n');
            if (nextline) {
                fprintf(fp, "%.*s", nextline + 1 - curline, curline);
                curline = nextline + 1;
                if (!*curline) break;
            } else {
                fputs(curline, fp);
                fputc('\n', fp);
                break;
            }
        }
        
        fclose(fp);
    }
}

static wchar_t *msgbox_buf = NULL;

void plugin_plog(const char *module, const char *fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    char msgbuf[MAXLINE];
    vsnprintf(msgbuf, sizeof(msgbuf), fmt, ap);
    write_plugin_log(module, msgbuf);
    va_end(ap);
}

void plugin_warning(const char *module, const char *fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    char msgbuf[MAXLINE];
    vsnprintf(msgbuf, sizeof(msgbuf), fmt, ap);
    write_plugin_log(module, msgbuf);    
    try_goto_desktop();
    MessageBoxW(NULL, cs2wcs_managed(msgbuf, CP_UTF8, &msgbox_buf), L"PAL3patch Plugin Host", MB_ICONWARNING | MB_TOPMOST | MB_SETFOREGROUND);
    va_end(ap);
}

void plugin_fail(const char *module, const char *fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    char msgbuf[MAXLINE];
    vsnprintf(msgbuf, sizeof(msgbuf), fmt, ap);
    write_plugin_log(module, msgbuf);
    try_goto_desktop();
    MessageBoxW(NULL, cs2wcs_managed(msgbuf, CP_UTF8, &msgbox_buf), L"PAL3patch Plugin Host", MB_ICONERROR | MB_TOPMOST | MB_SETFOREGROUND);
    die(2);
    va_end(ap);
}


#define pplog(fmt, ...) plugin_plog("PAL3PATCH", fmt, ##__VA_ARGS__)

static void try_load_module(const wchar_t *module)
{
    static char *module_utf8 = NULL;
    wcs2cs_managed(module, CP_UTF8, &module_utf8);
    
    HMODULE hModule = NULL;
    DECL_PLUGINENTRY(*entry);
    int r;
    
    hModule = LoadLibraryW(module);
    if (!hModule) {
        pplog("failed to load plugin '%s': LoadLibrary() failed", module_utf8);
        MessageBoxW_format(NULL, wstr_pluginerr_loadfailed_text, wstr_pluginerr_title, MB_ICONWARNING, module);
        goto fail;
    }

    entry = TOPTR(GetProcAddress(hModule, TOSTR(PLUGIN_ENTRY_NAME)));
    if (!entry) {
        pplog("failed to load plugin '%s': GetProcAddress() failed", module_utf8);
        MessageBoxW_format(NULL, wstr_pluginerr_noentry_text, wstr_pluginerr_title, MB_ICONWARNING, module, TOSTR(PLUGIN_ENTRY_NAME));
        goto fail;
    }
    
    r = entry();
    if (r != 0) {
        pplog("failed to load plugin '%s': entry procdure returns %d", module_utf8, r);
        MessageBoxW_format(NULL, wstr_pluginerr_initfailed_text, wstr_pluginerr_title, MB_ICONWARNING, module, r);
        goto fail;
    }
    
    pplog("loaded plugin '%s'", module_utf8);
    return;
    
fail:
    if (hModule) FreeLibrary(hModule);
    return;
}




static int str_have_wildcard(const wchar_t *str)
{
    return wcschr(str, L'*') || wcschr(str, L'?');
}

static void try_find_and_load_modules(const wchar_t *path)
{
    static char *fullpath_utf8 = NULL;
    
    wchar_t fullpath[MAXLINE];
    wchar_t *filepart;
    DWORD r;

    wchar_t modpath[MAXLINE];    
    WIN32_FIND_DATAW FindFileData;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    
    // convert to full path first    
    r = GetFullPathNameW(path, MAXLINE, fullpath, &filepart);
    if (r == 0 || r >= MAXLINE) goto done;
    if (!filepart) goto done;
    wcs2cs_managed(fullpath, CP_UTF8, &fullpath_utf8);

    // enum files
    hFind = FindFirstFileW(fullpath, &FindFileData);
    if (hFind == INVALID_HANDLE_VALUE) {
        if (!str_have_wildcard(fullpath)) {
            pplog("failed to load plugin '%s': no such file", fullpath_utf8);
            MessageBoxW_format(NULL, wstr_pluginerr_notfound_text, wstr_pluginerr_title, MB_ICONWARNING, fullpath);
        }
        goto done;
    }
    do {
        // skip dirs
        if ((FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) continue;
        
        // get dirname part
        wcscpy(modpath, fullpath);
        modpath[filepart - fullpath] = 0;
        
        // add slash if needed
        size_t l = wcslen(modpath);
        if (l && modpath[l - 1] != L'\\') {
            if (l + 1 >= MAXLINE) continue;
            modpath[l] = L'\\';
            modpath[l + 1] = 0;
        }
        
        // append filename
        if (wcslen(modpath) + wcslen(FindFileData.cFileName) >= MAXLINE) continue;
        wcscat(modpath, FindFileData.cFileName);
        
        // finally, load that module
        try_load_module(modpath);
        
    } while (FindNextFileW(hFind, &FindFileData));
    
done:
    if (hFind != INVALID_HANDLE_VALUE) FindClose(hFind);
}

void load_plugins(const wchar_t *cfgline)
{
    wchar_t buf[MAXLINE];
    if (wcslen(cfgline) >= MAXLINE) return;
    wcscpy(buf, cfgline);
    
    const wchar_t *delim = L";";
    wchar_t *ptr = buf, *end;
    wchar_t ch;

    do {
        while (*ptr && wcschr(delim, *ptr)) ptr++;
        for (end = ptr; *end && !wcschr(delim, *end); end++);
        ch = *end;
        *end = 0;
        if (*ptr) { // ptr is now a token
            try_find_and_load_modules(wcstrim(ptr, L" \""));
        }
        ptr = end + 1;
    } while (ch);
}


void init_plugins()
{
    wchar_t *plugin_cfgline = cs2wcs_alloc(get_string_from_configfile("plugins"), CP_UTF8);
    load_plugins(plugin_cfgline);
    free(plugin_cfgline);
}
