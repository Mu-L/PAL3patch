#include "common.h"


// misc

int version_string_compare(const char *a, const char *b)
{
    // compare two version strings, only compare numbers
    //   for example:
    //     v1.0 == x1.0
    //     v1 == v1.0.0
    //     v1.0 < v1.0.1
    //     v1.2 < v1.10
    //     v2.0 > v1.99
    
    unsigned na, nb;
    do {
        while (*a && !('0' <= *a && *a <= '9')) a++;
        for (na = 0; '0' <= *a && *a <= '9'; a++) na = na * 10 + (*a - '0');
        while (*b && !('0' <= *b && *b <= '9')) b++;
        for (nb = 0; '0' <= *b && *b <= '9'; b++) nb = nb * 10 + (*b - '0');
    } while (na == nb && (*a || *b));
    if (na < nb) return -1;
    if (na > nb) return 1;
    return 0;
}


// plugin log system

#define PLUGIN_LOG_FILE "PAL3patch.plugin_log.txt"

int plugin_log_indent = 0;

static void make_plugin_log_header()
{
    static int flag = 0;
    if (flag) return;
    flag = 1;
    
    FILE *fp = fopen(PLUGIN_LOG_FILE, "w");
    if (fp) {
        fputs(UTF8_BOM_STR, fp);
        fprintf(fp, "; PAL3patch Plugin Host Log File\n");
        fprintf(fp, "; generated by PAL3patch %s (built on %s)\n", patch_version, build_date);
    	fprintf(fp, "\n");
    	fprintf(fp, "%-23s | %-15s | %s\n", "; timestamp", "module", "message");
    	fprintf(fp, "\n");
        fclose(fp);
    }
}

static void write_plugin_log(const char *module, int indent, const char *message)
{
    make_plugin_log_header();
    
    int real_indent = (indent % MAX_PLUGIN_LOG_INDENT + MAX_PLUGIN_LOG_INDENT) % MAX_PLUGIN_LOG_INDENT;
    int i;
    
    FILE *fp = fopen(PLUGIN_LOG_FILE, "a");
    if (fp) {
        SYSTEMTIME SystemTime;
        GetLocalTime(&SystemTime);

        const char *curline = message;
        while (1) {
            fprintf(fp, "%04hu-%02hu-%02hu %02hu:%02hu:%02hu.%03hu | %-15s | ", SystemTime.wYear, SystemTime.wMonth, SystemTime.wDay, SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond, SystemTime.wMilliseconds, module ? module : "UNKNOWN");
            for (i = 1; i <= real_indent; i++) fputs("  ", fp);
            const char *nextline = strchr(curline, '\n');
            if (nextline) {
                fprintf(fp, "%.*s", nextline + 1 - curline, curline);
                curline = nextline + 1;
                if (!*curline) break;
            } else {
                fputs(curline, fp);
                fputc('\n', fp);
                break;
            }
        }
        
        fclose(fp);
    }
}

static wchar_t *msgbox_buf = NULL;

void plugin_plog(const char *module, int indent, const char *fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    char msgbuf[MAXLINE];
    vsnprintf(msgbuf, sizeof(msgbuf), fmt, ap);
    write_plugin_log(module, indent, msgbuf);
    va_end(ap);
}

void plugin_warning(const char *module, int indent, const char *fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    char msgbuf[MAXLINE];
    vsnprintf(msgbuf, sizeof(msgbuf), fmt, ap);
    write_plugin_log(module, indent, msgbuf);    
    try_goto_desktop();
    MessageBoxW(NULL, cs2wcs_managed(msgbuf, CP_UTF8, &msgbox_buf), L"PAL3patch Plugin Host", MB_ICONWARNING | MB_TOPMOST | MB_SETFOREGROUND);
    va_end(ap);
}

void plugin_fail(const char *module, int indent, const char *fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    char msgbuf[MAXLINE];
    vsnprintf(msgbuf, sizeof(msgbuf), fmt, ap);
    write_plugin_log(module, indent, msgbuf);
    try_goto_desktop();
    MessageBoxW(NULL, cs2wcs_managed(msgbuf, CP_UTF8, &msgbox_buf), L"PAL3patch Plugin Host", MB_ICONERROR | MB_TOPMOST | MB_SETFOREGROUND);
    die(2);
    va_end(ap);
}




// plugin loader



#define pplog(fmt, ...) plugin_plog("PAL3PATCH", plugin_log_indent, fmt, ##__VA_ARGS__)
#define pplog_enter() (++plugin_log_indent)
#define pplog_leave() (--plugin_log_indent)

struct plugin_desc {
    HMODULE handle;
    DECL_PLUGINENTRY(*entry);
    
    struct plugin_desc *next;
};

static int total_plugins = 0;
static struct plugin_desc *plugin_list_head = NULL;


static int check_register_plugin(struct plugin_desc *newplugin)
{
    struct plugin_desc *ptr;
    for (ptr = plugin_list_head; ptr; ptr = ptr->next) {
        if (ptr->handle == newplugin->handle || ptr->entry == newplugin->entry) {
            return 0;
        }
    }
    return 1;
}
static void do_register_plugin(struct plugin_desc *newplugin)
{
    newplugin->next = plugin_list_head;
    plugin_list_head = newplugin;
    total_plugins++;
}

static void load_plugin_dll_with_mode(const char *filename, int mode)
{
    // mode == 0: normal LoadLibrary
    // mode == 1: call LoadLibraryEx with parameter LOAD_WITH_ALTERED_SEARCH_PATH
    DWORD dwFlags;
    wchar_t *wfilename_managed = NULL;
    struct plugin_desc *newplugin = NULL;
    HMODULE hModule = NULL;
    DECL_PLUGINENTRY(*entry);
    int r;
    

    switch (mode) {
        case 0: dwFlags = 0; break;
        case 1: dwFlags = LOAD_WITH_ALTERED_SEARCH_PATH; break;
        default: pplog("error: unknown dll load mode %d.", mode); goto fail;
    }
    
    newplugin = malloc(sizeof(struct plugin_desc));
    
    cs2wcs_managed(filename, CP_UTF8, &wfilename_managed);
    newplugin->handle = hModule = LoadLibraryExW(wfilename_managed, NULL, dwFlags);
    if (!hModule) {
        pplog("error: LoadLibraryEx() failed.");
        MessageBoxW_format(NULL, wstr_pluginerr_loadfailed_text, wstr_pluginerr_title, MB_ICONWARNING, wfilename_managed);
        goto fail;
    }
    
    newplugin->entry = entry = TOPTR(GetProcAddress(hModule, TOSTR(PLUGIN_ENTRY_NAME)));
    if (!entry) {
        pplog("error: GetProcAddress() failed.");
        MessageBoxW_format(NULL, wstr_pluginerr_noentry_text, wstr_pluginerr_title, MB_ICONWARNING, wfilename_managed, TOSTR(PLUGIN_ENTRY_NAME));
        goto fail;
    }
    
    if (!check_register_plugin(newplugin)) {
        pplog("plugin already loaded.");
        goto skip;
    }
    
    pplog("executing plugin initialization procedure ...");
    pplog_enter();
    r = entry();
    pplog_leave();
    if (r != 0) {
        pplog("error: initialization procedure returns %d.", r);
        MessageBoxW_format(NULL, wstr_pluginerr_initfailed_text, wstr_pluginerr_title, MB_ICONWARNING, wfilename_managed, r);
        goto fail;
    }
    
    do_register_plugin(newplugin);
    pplog("plugin loaded successfully.");
    
done:
    if (wfilename_managed) free(wfilename_managed);
    return;
fail:
skip:
    if (newplugin) free(newplugin);
    if (hModule) FreeLibrary(hModule);
    goto done;
}

void load_plugin_dll(const char *filename)
{
    pplog("loading plugin dll '%s' ...", filename);
    pplog_enter();
    load_plugin_dll_with_mode(filename, 0);
    pplog_leave();
}
void load_plugin_dll_and_dependents(const char *filename)
{
    pplog("loading plugin dll '%s' and its dependents ...", filename);
    pplog_enter();
    load_plugin_dll_with_mode(filename, 1);
    pplog_leave();
}

void load_plugin_list(const char *filename)
{
    char *filedata = NULL;
    char *cstr_managed = NULL;
    wchar_t *wstr_managed = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    wchar_t wbuf[MAXLINE];
    wchar_t fullpath[MAXLINE];
    wchar_t *fullpath_filepart;
    DWORD dwSize, dwRead;
    char *filestr;
    char *line;
    const char *line_delim = "\r\n";
    char *line_saveptr;
    char *directive, *parameter;
    char *token_saveptr;
    
    pplog("executing plugin file '%s' ...", filename);
    pplog_enter();
    
    // convert utf8 filename to unicode full path name
    cs2wcs_managed(filename, CP_UTF8, &wstr_managed);
    GetFullPathNameW(wstr_managed, MAXLINE, fullpath, &fullpath_filepart);
    
    // read whole file as a string
    hFile = CreateFileW(fullpath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        pplog("error: can't open plugin file.");
        goto fail;
    }
    dwSize = GetFileSize(hFile, NULL);
    if (dwSize == INVALID_FILE_SIZE) goto fail;
    filedata = malloc(dwSize + 1);
    if (!ReadFile(hFile, filedata, dwSize, &dwRead, NULL) || dwSize != dwRead) goto fail;
    filedata[dwSize] = 0;
    filestr = filedata;
    
    // skip utf8 bom if needed
    if (strncmp(filestr, UTF8_BOM_STR, UTF8_BOM_LEN) == 0) filestr += UTF8_BOM_LEN;
    
    // parse the file
    for (line = strtok_r(filestr, line_delim, &line_saveptr); line; line = strtok_r(NULL, line_delim, &line_saveptr)) {
        //pplog("line = [%s]", line);
        
        directive = strtok_r(line, SPACECHAR_LIST, &token_saveptr);
        if (!directive || *directive == '#' || *directive == ';' || (directive[0] == '/' && directive[1] == '/')) continue;
        
        if (stricmp(directive, "END") == 0 || stricmp(directive, "EXIT") == 0 || stricmp(directive, "QUIT") == 0) {
            break;
        }
        
        parameter = strtok_r(NULL, line_delim, &token_saveptr); // use line_delim to fetch the whole remaining string
        if (!parameter) {
            pplog("error: no parameter directive '%s'.", directive);
            goto fail;
        }
        str_trim(parameter, SPACECHAR_LIST);

        // construct dirname in buffer
        wcscpy(wbuf, fullpath);
        wbuf[fullpath_filepart - fullpath] = 0;
        
        // convert parameter to fullpath and append to buffer
        cs2wcs_managed(parameter, CP_UTF8, &wstr_managed);
        if (wcslen(wbuf) + wcslen(wstr_managed) >= MAXLINE) goto fail;
        wcscat(wbuf, wstr_managed);
        
        // convert buffer to utf8 string
        wcs2cs_managed(wbuf, CP_UTF8, &cstr_managed);
        parameter = cstr_managed;
        
        //pplog("parameter = [%s]", parameter);

        if (stricmp(directive, "DLL") == 0 || stricmp(directive, "LOAD_DLL") == 0) {
            load_plugin_dll(parameter);
        } else if (stricmp(directive, "DLL2") == 0 || stricmp(directive, "LOAD_DLL_AND_DEPENDENTS") == 0) {
            load_plugin_dll_and_dependents(parameter);
        } else if (stricmp(directive, "LIST") == 0 || stricmp(directive, "LOAD_PLUGIN") == 0) {
            load_plugin_list(parameter);
        } else if (stricmp(directive, "DIR") == 0 || stricmp(directive, "SEARCH_DIR") == 0) {
            search_plugins(parameter);
        } else {
            pplog("error: unknown directive '%s'.", directive);
            goto fail;
        }
    }
    
done:
    if (filedata) free(filedata);
    if (cstr_managed) free(cstr_managed);
    if (wstr_managed) free(wstr_managed);
    if (hFile) CloseHandle(hFile);
    pplog("execution finished.");
    pplog_leave();
    return;
fail:
    pplog("error occurred while executing plugin file.");
    goto done;
}

static int wfilename_cmp(const void *a, const void *b)
{
    const wchar_t * const *pa = a;
    const wchar_t * const *pb = b;
    return wcsicmp(*pa, *pb);
}

static void enum_files(const char *dirpath, const char *pattern, void (*func)(const char *filepath))
{
    char *cstr_managed = NULL;
    wchar_t *wstr_managed = NULL;
    char buf[MAXLINE];
    wchar_t wbuf[MAXLINE];
    wchar_t searchpatt[MAXLINE];
    wchar_t *searchpatt_filepart;
    wchar_t *filelist[MAXLINE];
    int nr_filelist = 0;
    int i;
    DWORD r;
    WIN32_FIND_DATAW FindFileData;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    
    // construct utf8 search pattern
    snprintf(buf, sizeof(buf), "%s\\%s", dirpath, pattern);
    if (strlen(buf) >= MAXLINE - 1) goto fail;
    
    // convert to unicode-string
    cs2wcs_managed(buf, CP_UTF8, &wstr_managed);
    
    // convert to fullpath
    r = GetFullPathNameW(wstr_managed, MAXLINE, searchpatt, &searchpatt_filepart);
    if (r == 0 || r >= MAXLINE || !searchpatt_filepart) goto fail;
    
    
    // do enum
    hFind = FindFirstFileW(searchpatt, &FindFileData);
    if (hFind == INVALID_HANDLE_VALUE) {
        // no such file found
        pplog("no file found in directory '%s' with pattern '%s'.", dirpath, pattern);
        goto done;
    }
    do {
        // skip dirs
        if ((FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) continue;
        
        // construct dirname
        wcscpy(wbuf, searchpatt);
        wbuf[searchpatt_filepart - searchpatt] = 0;
        
        // append filename
        if (wcslen(wbuf) + wcslen(FindFileData.cFileName) >= MAXLINE) goto fail;
        wcscat(wbuf, FindFileData.cFileName);
        
        // add to file list
        if (nr_filelist >= MAXLINE) goto fail;
        filelist[nr_filelist++] = wcsdup(wbuf);
        
    } while (FindNextFileW(hFind, &FindFileData));
    
    // sort files
    qsort(filelist, nr_filelist, sizeof(wchar_t *), wfilename_cmp);
    
    for (i = 0; i < nr_filelist; i++) {
        // convert to utf8 and invoke function
        wcs2cs_managed(filelist[i], CP_UTF8, &cstr_managed);
        func(cstr_managed);
    }
    
done:
    for (i = 0; i < nr_filelist; i++) {
        free(filelist[i]);
    }
    if (cstr_managed) free(cstr_managed);
    if (wstr_managed) free(wstr_managed);
    if (hFind != INVALID_HANDLE_VALUE) FindClose(hFind);
    return;
fail:
    pplog("error occurred while enumerating files.");
    goto done;
}

void search_plugins(const char *dirpath)
{
    pplog("searching plugins in directory '%s' ...", dirpath);
    pplog_enter();
    enum_files(dirpath, "*.plugin", load_plugin_list);
    enum_files(dirpath, "*.dll", load_plugin_dll);
    pplog("search finished.");
    pplog_leave();
}

void init_plugins()
{
    int flag = get_int_from_configfile("loadplugins");
    if (flag) {
        search_plugins("plugins");
        pplog("total %d plugin%s loaded at game startup time.\n\n\n", total_plugins, total_plugins > 1 ? "s" : "");
    }
}
