【当铺收购可能卡住的问题】
游戏攻略中讲：（1）丁级当铺可以收购12件物品；（2）每次点收购会从可收购物品表中随机产生一个子表，作为该次显示的收购表格

BUG重现方法：新安当升到丁级，然后收购几次（每次一个物品，大约5次）
 退出当铺游戏菜单，再进入当铺游戏菜单，再收购几次（每次一个物品），点击收购时可能卡住

用od断下，在51f5a4处循环内死循环，该循环用来根据随机数产生收购的列表（子表）
该循环属于某（猜测是当铺菜单）类的OnMessage虚函数
该段代码属于当铺的代码，在PDB文件中没有相关的数据结构信息
////////////////// 片段1
        total_objcnt = 0;                       // 总物品数量
        *(_DWORD *)(v4 + 4 * v13 + 345556) = 0; // 生成的子表的大小
        if ( *(_DWORD *)(v4 + 4 * v13 + 8028) > 0 )
        {
          v14 = v4 + 79992 * v13 + 8852;
          do
          {
            *(_BYTE *)(v14 + 1) = 0;            // 清除:是否已被子表选中
            if ( !*(_BYTE *)v14 )               // 此处可能缺少一个判断条件（根据后面代码推出）
                                                // *(DWORD *)(v14-800) != 0
              ++total_objcnt;
            ++v12;
            v14 += 808;
          }
          while ( v12 < *(_DWORD *)(v4 + 4 * v13 + 8028) );
        }
        v15 = *(_DWORD *)(v4 + 8048);
        a3a = 0;
        show_objcnt = *(_DWORD *)(v15 + 16);
        show_objcnt += rand() % (*(_DWORD *)(v15 + 20) - show_objcnt);
        if ( show_objcnt <= 0 )                 // 子表的目标大小
          goto LABEL_31;
        break;
////////////////// 片段2
    while ( total_objcnt > 0 )
    {
      v16 = rand() % *(_DWORD *)(v4 + 4 * v13 + 8028);
      if ( total_objcnt <= show_objcnt )        // 如果目标大小比总可用物品还多,则直接拷贝整个表
      {
        v18 = 0;
        if ( *(_DWORD *)(v4 + 4 * v13 + 8028) > 0 )
        {
          v19 = (_DWORD *)(v4 + 808 * (wparama + 66 * v13 + 33 * v13) + 8856);
          v20 = (_BYTE *)(v4 + 79992 * v13 + 8853);
          do
          {
            if ( !*(v20 - 1) && !*v20 && *(_DWORD *)(v20 - 801) )// 三个条件
            {
              *v20 = 1;
              *v19 = v18;
              ++wparama;
              v19 += 202;
              ++*(_DWORD *)(v4 + 4 * v13 + 345556);
            }
            ++v18;
            v20 += 808;
          }
          while ( v18 < *(_DWORD *)(v4 + 4 * v13 + 8028) );
        }
        break;
      }
      v17 = v4 + 808 * (99 * v13 + v16);
      if ( !*(_BYTE *)(v4 + 808 * (99 * v13 + v16) + 8852) && !*(_BYTE *)(v17 + 8853) && *(_DWORD *)(v17 + 8052) )// 三个条件
      {
        *(_BYTE *)(v17 + 8853) = 1;
        *(_DWORD *)(v4 + 808 * (99 * v13 + wparama++) + 8856) = v16;
        ++a3a;
        ++*(_DWORD *)(v4 + 4 * v13 + 345556);
      }
      if ( a3a >= show_objcnt )
        break;
    }
用OD动态调试发现，total_objcnt和show_objcnt这两个变量的意义
show_objcnt在2和3之间变动（丁级当铺每次收购显示2-3个物品）
每次收购后，total_objcnt都会减小（可用物品变少）
另外，多次尝试后发现，当铺升级后，如果有收购列表里有古董，一旦退出当铺游戏菜单，再进入收购界面，古董就从此消失了（至少短时间内肯定不会出现了）
而本BUG就与这个现象有关：统计total_objcnt的地方判断只有一个条件——[偏移8852的BYTE]==0
而随机数产生后，或者因为可用物品太少直接复制清单时，决定物品是否加入是有三个条件的：
（1）[偏移8852的BYTE]==0   猜测是用来判断物品是否有效的（但是很奇怪，判断条件是==0）
（2）[偏移8853的BYTE]==0   这个BYTE用于记录该物品是否已经放入列表中，会在统计total_objcnt是清零（见代码片段1）
（3）[偏移8052的DWORD]!=0  这个就是导致我们这个BUG的罪魁祸首，猜测与“古董消失”现象有关，若用OD强制对其设置值1会导致游戏崩溃
可以看到，在统计total_objcnt是没有考虑到[偏移8052的DWORD]这个条件，因此可能导致之后的随机过程永远无法停止
经初步分析，total_objcnt就是一个简单的局部变量，只会影响其后的随机轮数，修改它不会造成太大影响
因此决定：修复的办法就是在统计total_objcnt时，在多加一个判断条件*(DWORD *)(v14-800) != 0

