#include "stdafx.h"
#include "ConfigData.h"
#include "PatchVersionInfo.h"
#include "Resource.h"
#include <map>

#define CONFIG_FILE "PAL3patch.conf"
#define MAXLINE 4096

static int is_spacechar(char ch)
{
	return !!strchr(" \t\n\v\f\r", ch);
}

static std::map<CString, CString> cfgdata;

static int TryReadConfigFile()
{
	cfgdata.clear();
	int ret = 0;
    FILE *fp = fopen(CONFIG_FILE, "r");
    if (!fp) goto done;
    char buf[MAXLINE];
    char *ptr;
    while (fgets(buf, sizeof(buf), fp)) {
        // ltrim the line
        for (ptr = buf; *ptr && is_spacechar(*ptr); ptr++);
        memmove(buf, ptr, strlen(ptr) + 1);
        
        // skip empty and comment lines
        if (!buf[0] || buf[0] == ';' || buf[0] == '#' || (buf[0] == '/' && buf[1] == '/')) continue;
        
        // remove '\n' and end of line
        ptr = strchr(buf, '\n');
        if (ptr) *ptr = '\0';
        
        // parse 'key' and 'value'
        ptr = strchr(buf, '=');
        if (!ptr) goto done;
        *ptr = '\0';
        char *keystr = buf, *valstr = ptr + 1;
        
        // rtrim 'key'
        if (ptr > buf) ptr--;
        while (ptr >= buf && is_spacechar(*ptr)) *ptr-- = '\0';
        if (!*ptr) goto done;
        
        // ltrim 'value'
        while (*valstr && is_spacechar(*valstr)) valstr++;
        
        // save this config line to array
		cfgdata.insert(std::make_pair(CString(keystr), CString(valstr)));
    }

    ret = 1;
done:
	if (fp) fclose(fp);
	return ret;
}

int TryRebuildConfigFile()
{
	HRSRC hRes = FindResource(NULL, MAKEINTRESOURCE(IDR_DEFCONFIG), RT_RCDATA);
	if (!hRes) return 0;
	HGLOBAL hData = LoadResource(NULL, hRes);
	if (!hData) return 0;
	DWORD datalen = SizeofResource(NULL, hRes);
	if (!datalen) return 0;
	void *pData = LockResource(hData);
	if (!pData) return 0;

	FILE *fp = fopen(CONFIG_FILE, "wb");
	if (!fp) return 0;

	fwrite(pData, 1, datalen, fp);
	fclose(fp);

	return 1;
}

static int TryMatchConfigData()
{
	std::map<CString, CString>::iterator it;
	ConfigDescItem *pItem;
	for (pItem = ConfigDescList; pItem->level >= 0; pItem++) {
		if (pItem->key) {
			// no need to free 'pItem->pvalue', automaticly freed by std::map
			if ((it = cfgdata.find(CString(pItem->key))) != cfgdata.end()) {
				pItem->pvalue = &it->second;
			} else {
				return 0;
			}
		}
	}
	return 1;
}

int TryLoadConfigData()
{
	return TryReadConfigFile() && TryMatchConfigData();
}

int TrySaveConfigData()
{
	std::map<CString, CString>::iterator it;
	FILE *fp = fopen(CONFIG_FILE, "w");
	if (!fp) return 0;
	
	SYSTEMTIME SystemTime;
    GetLocalTime(&SystemTime);
	fprintf(fp, "; generated by Patch Configure Utility %s (built on %s)\n", pVersionStr, pBuildDate);
	fprintf(fp, "; last modification: %04hd-%02hd-%02hd %02hd:%02hd:%02hd.%03hd\n", SystemTime.wYear, SystemTime.wMonth, SystemTime.wDay, SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond, SystemTime.wMilliseconds);
	fprintf(fp, "\n");
	for (it = cfgdata.begin(); it != cfgdata.end(); it++) {
		LPCTSTR keystr = it->first;
		LPCTSTR valstr = it->second;
#if defined(_UNICODE)
		int keylen = WideCharToMultiByte(CP_ACP, 0, keystr, -1, NULL, 0, NULL, NULL);
		int vallen = WideCharToMultiByte(CP_ACP, 0, valstr, -1, NULL, 0, NULL, NULL);
		if (!keylen || !vallen) goto done;
		char *keybuf = (char *) malloc(keylen);
		char *valbuf = (char *) malloc(vallen);
		WideCharToMultiByte(CP_ACP, 0, keystr, -1, keybuf, keylen, NULL, NULL);
		WideCharToMultiByte(CP_ACP, 0, valstr, -1, valbuf, vallen, NULL, NULL);
		fprintf(fp, "%s=%s\n", keybuf, valbuf);
		free(keybuf);
		free(valbuf);
#elif defined(_MBCS)
		fprintf(fp, "%s=%s\n", keystr, valstr);
#else
#error 
#endif
	}
done:
	if (fp) fclose(fp);
	return 1;
}
